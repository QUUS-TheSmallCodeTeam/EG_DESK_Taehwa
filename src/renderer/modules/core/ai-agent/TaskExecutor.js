/**
 * TaskExecutor - Task Execution Engine
 * 
 * Manages and executes tasks generated by AI or user commands.
 * As specified in PRD: AI-Agent-System/TaskExecutor.js
 */

import { EventEmitter } from '../../../utils/EventEmitter.js';

class TaskExecutor extends EventEmitter {
  constructor(options = {}) {
    super();
    this.options = {
      maxConcurrentTasks: options.maxConcurrentTasks || 5,
      retryLimit: options.retryLimit || 3,
      ...options
    };

    this.tasks = new Map();
    this.isInitialized = false;
  }

  /**
   * Initialize task executor
   */
  async initialize() {
    try {
      console.log('[TaskExecutor] Initializing...');
      this.isInitialized = true;
      console.log('[TaskExecutor] Successfully initialized');
      this.emit('initialized');
      return true;
    } catch (error) {
      console.error('[TaskExecutor] Initialization failed:', error);
      this.emit('error', error);
      throw error;
    }
  }

  /**
   * Add new task
   */
  async addTask(task) {
    const taskId = this.generateTaskId();
    const taskObj = {
      id: taskId,
      ...task,
      status: 'pending',
      retries: 0
    };
    this.tasks.set(taskId, taskObj);
    console.log(`[TaskExecutor] Added new task: ${taskId}`);
    this.emit('task-added', taskObj);
    this.executeTask(taskId);
    return taskId;
  }

  /**
   * Execute a task
   */
  async executeTask(taskId) {
    if (!this.tasks.has(taskId)) {
      throw new Error(`Task ${taskId} not found`);
    }

    const task = this.tasks.get(taskId);
    try {
      task.status = 'running';
      console.log(`[TaskExecutor] Executing task: ${taskId}`);
      this.emit('task-started', task);
      
      // Execute task logic here
      await task.executionLogic();

      task.status = 'completed';
      console.log(`[TaskExecutor] Task completed: ${taskId}`);
      this.emit('task-completed', task);
      this.tasks.delete(taskId);
    } catch (error) {
      console.error(`[TaskExecutor] Task execution failed: ${taskId}`, error);
      task.status = 'failed';
      task.retries++;
      if (task.retries <= this.options.retryLimit) {
        console.log(`[TaskExecutor] Retrying task: ${taskId} (${task.retries}/${this.options.retryLimit})`);
        this.executeTask(taskId);
      } else {
        this.emit('task-failed', task);
        this.tasks.delete(taskId);
      }
    }
  }

  /**
   * Cancel a task
   */
  cancelTask(taskId) {
    if (this.tasks.has(taskId)) {
      const task = this.tasks.get(taskId);
      task.status = 'cancelled';
      console.log(`[TaskExecutor] Task cancelled: ${taskId}`);
      this.emit('task-cancelled', task);
      this.tasks.delete(taskId);
    } else {
      throw new Error(`Task ${taskId} not found for cancellation`);
    }
  }

  /**
   * Get task status
   */
  getTaskStatus(taskId) {
    if (this.tasks.has(taskId)) {
      const task = this.tasks.get(taskId);
      return {
        id: taskId,
        status: task.status,
        retries: task.retries,
        ...task.metadata
      };
    }
    return null;
  }

  /**
   * Generate unique task ID
   */
  generateTaskId() {
    return `task_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
  }

  /**
   * Destroy task executor
   */
  destroy() {
    this.tasks.clear();
    this.isInitialized = false;
    this.removeAllListeners();
    console.log('[TaskExecutor] Destroyed');
  }
}

export default TaskExecutor;

